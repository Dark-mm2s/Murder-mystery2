-- AUTO COPY DISCORD INVITE
local discordLink = "https://discord.gg/M6uDjC2VT"

pcall(function()
    if setclipboard then
        setclipboard(discordLink)
    elseif toclipboard then
        toclipboard(discordLink)
    end
end)

local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

-- Gradient function for multi-colored text
local function gradient(text, startColor, endColor)
    local result = ""
    local length = #text
    for i = 1, length do
        local t = (i - 1) / math.max(length - 1, 1)
        local r = math.floor((startColor.R + ((endColor.R - startColor.R) * t)) * 255)
        local g = math.floor((startColor.G + ((endColor.G - startColor.G) * t)) * 255)
        local b = math.floor((startColor.B + ((endColor.B - startColor.B) * t)) * 255)
        local char = text:sub(i, i)
        result = result .. '<font color="rgb(' .. r .. ", " .. g .. ", " .. b .. ')">' .. char .. "</font>"
    end
    return result
end

-- Confirmation variable
local Confirmed = false

-- Popup before UI loads
WindUI:Popup({
    Title = gradient("DARK MM2", Color3.fromHex("#8B5CF6"), Color3.fromHex("#C084FC")),
    Icon = "info",
    Content = gradient("Would You Like To Load ", Color3.fromHex("#A855F7"), Color3.fromHex("#E9D5FF")) .. gradient("DARK MM2?", Color3.fromHex("#8B5CF6"), Color3.fromHex("#C084FC")),
    Buttons = {
        {
            Title = gradient("Cancel", Color3.fromHex("#EF4444"), Color3.fromHex("#991B1B")),
            Callback = function()
                -- Script stops, nothing loads
            end,
            Variant = "Tertiary",
        },
        {
            Title = gradient("Load", Color3.fromHex("#10B981"), Color3.fromHex("#059669")),
            Icon = "arrow-right",
            Callback = function()
                Confirmed = true
            end,
            Variant = "Primary",
        }
    }
})

-- Wait until user confirms
repeat
    task.wait()
until Confirmed

-- Success notification after confirmation
WindUI:Notify({
    Title = gradient("DARK MM2", Color3.fromHex("#8B5CF6"), Color3.fromHex("#C084FC")),
    Content = "Hub Successfully Loaded! üéÑ",
    Icon = "check-circle",
    Duration = 3
})

local Window = WindUI:CreateWindow({
    Title = gradient("Rhyzen Hub", Color3.fromHex("#8B5CF6"), Color3.fromHex("#C084FC")),
    Icon = "",
    Author = "Murder Mystery 2 Hub (Christmas Version ‚ùÑÔ∏è)",
    Folder = "Made By the Dark developer",
})

local spawnTab = Window:Tab({
    Title = "Weapon Spawner",
    Icon = "gift",
    Locked = false,
})

local farmTab = Window:Tab({
    Title = "Auto Farm",
    Icon = "trending-up",
    Locked = false,
})

-- NEW: Teleport Tab
local teleportTab = Window:Tab({
    Title = "Teleport",
    Icon = "user",
    Locked = false,
})

-- ==================== VARIABLES ====================
local itemNameInput = ""
local quantityInput = 0

-- Auto Farm Variables
local autoFarmCandy = false
local autoFarmSnowflakes = false
local visitedPositions = {}
local flySpeed = 16
local collected = 0
local currentBagAmount = 0
local character
local rootPart
local autoResetEnabled = false
local resetting = false
local bag_full = false

-- ESP Variables
local murderHasKnife = false
local sheriffHasGun = false
local currentESPOptions = { "Esp All" }
local highlightEnabled = true
local lineESPEnabled = false
local tracers = {}

-- Teleport Variables
local teleportTarget = nil
local teleportDropdown = nil
local Murder, Sheriff, Hero = nil, nil, nil
local roles = {}

-- Services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

-- Purple Theme Colors
local PurpleTheme = {
    Primary = Color3.fromHex("#8B5CF6"),
    Secondary = Color3.fromHex("#A855F7"),
    Accent = Color3.fromHex("#C084FC"),
    Dark = Color3.fromHex("#4C1D95"),
    Light = Color3.fromHex("#E9D5FF"),
    Success = Color3.fromHex("#10B981"),
    Warning = Color3.fromHex("#F59E0B"),
    Error = Color3.fromHex("#EF4444"),
    Background = Color3.fromHex("#1a1a2e")
}

-- Player Data
local success, PlayerData = pcall(function()
    return require(game:GetService("ReplicatedStorage").Modules.ProfileData)
end)

if not success then
    WindUI:Notify({
        Title = "Error",
        Content = "Failed to load PlayerData module!",
        Duration = 5
    })
    return
end

local PlayerWeapons = PlayerData.Weapons
local crate = "Christmas2025Box"
local _R = game:GetService("ReplicatedStorage")

-- Items Database
local ITEMS = {
    Gingerscope = "Gingerscope",
    Harvester = "Harvester",
    TreeGun2023 = "TreeGun2023",
    TreeGun2023Chroma = "TreeGun2023Chroma",
    TreeKnife2023 = "TreeKnife2023",
    TreeKnife2023Chroma = "TreeKnife2023Chroma",
    TravelerGun = "TravelerGun",
    TravelerGunChroma = "TravelerGunChroma",
    WaterGunChroma = "WaterGunChroma",
    BaubleChroma = "BaubleChroma",
    TravelerAxe = "TravelerAxe",
    Sunset = "SunsetGun",
    Sunrise = "SunsetKnife",
    Icepiercer = "Icepiercer",
    Raygun = "Raygun",
    XenoKnife = "XenoKnife",
    XenoGun = "XenoGun",
    RaygunChroma = "RaygunChroma",
    Alienbeam = "UFOKnife"
}

-- Inventory Tracking
local inventory = {}

-- ==================== REMOTE CHECK ====================
print("Checking for remotes...")

local remotesFolder = _R:FindFirstChild("Remotes")
if not remotesFolder then
    WindUI:Notify({
        Title = "Error",
        Content = "Remotes Folder Not Found!",
        Duration = 5
    })
    warn("Remotes folder not found in ReplicatedStorage")
    return
end

local gameplayFolder = remotesFolder:FindFirstChild("Gameplay")
local CoinCollected = gameplayFolder and gameplayFolder:FindFirstChild("CoinCollected")

local shopFolder = remotesFolder:FindFirstChild("Shop")
if not shopFolder then
    WindUI:Notify({
        Title = "Error",
        Content = "Shop Folder Not Found!",
        Duration = 5
    })
    warn("Shop folder not found in Remotes")
    return
end

local _B = shopFolder:FindFirstChild("BoxController")
if not _B then
    WindUI:Notify({
        Title = "Error",
        Content = "Box Controller Not Found!",
        Duration = 5
    })
    warn("BoxController not found in Shop folder")
    return
end

print("All remotes found successfully!")
print("BoxController type:", typeof(_B))

-- ==================== TELEPORT HELPER FUNCTIONS ====================
local function IsAlive(player)
    for name, data in pairs(roles) do
        if player.Name == name then
            return not data.Killed and not data.Dead
        end
    end
    return false
end

local function UpdateRoles()
    local success, result = pcall(function()
        return ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    end)
    
    if success and result then
        roles = result
        Murder, Sheriff, Hero = nil, nil, nil
        
        for name, data in pairs(roles) do
            if data.Role == "Murderer" then
                Murder = name
            elseif data.Role == "Sheriff" then
                Sheriff = name
            elseif data.Role == "Hero" then
                Hero = name
            end
        end
    end
end

local function updateTeleportPlayers()
    local playersList = {"Select Player"}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playersList, player.Name)
        end
    end
    return playersList
end

local function teleportToPlayer()
    if teleportTarget and teleportTarget.Character then
        local targetRoot = teleportTarget.Character:FindFirstChild("HumanoidRootPart")
        local localRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        
        if targetRoot and localRoot then
            localRoot.CFrame = targetRoot.CFrame
            WindUI:Notify({
                Title = "Teleportation",
                Content = "Successfully teleported to " .. teleportTarget.Name,
                Icon = "check-circle",
                Duration = 3
            })
        end
    else
        WindUI:Notify({
            Title = "Error",
            Content = "Target not found or unavailable",
            Icon = "x-circle",
            Duration = 3
        })
    end
end

local function teleportToLobby()
    local lobby = Workspace:FindFirstChild("Lobby")
    if not lobby then
        WindUI:Notify({
            Title = "Teleport",
            Content = "Lobby not found!",
            Icon = "x-circle",
            Duration = 2
        })
        return
    end
    
    local spawnPoint = lobby:FindFirstChild("SpawnPoint") or lobby:FindFirstChildOfClass("SpawnLocation")
    if not spawnPoint then
        spawnPoint = lobby:FindFirstChildWhichIsA("BasePart") or lobby
    end
    
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(spawnPoint.Position + Vector3.new(0, 3, 0))
        WindUI:Notify({
            Title = "Teleport",
            Content = "Teleported to Lobby!",
            Icon = "check-circle",
            Duration = 2
        })
    end
end

-- ==================== ESP FUNCTIONS ====================
local function getRole(player)
    local character = player.Character
    if not character then return nil end
    local backpack = player:FindFirstChild("Backpack")
    if character:FindFirstChild("Knife") or (backpack and backpack:FindFirstChild("Knife")) then return "Murderer" end
    if character:FindFirstChild("Gun") or (backpack and backpack:FindFirstChild("Gun")) then return "Sheriff" end
    return "Innocent"
end

local function isPlayerTargeted(player, selectedOptions)
    local role = getRole(player)
    if not role then return false end
    if table.find(selectedOptions, "Esp All") then return true end
    if table.find(selectedOptions, "Esp Murder") and role == "Murderer" then return true end
    if table.find(selectedOptions, "Esp Sheriff") and role == "Sheriff" then return true end
    if table.find(selectedOptions, "Esp Sheriff / Murder") and (role == "Sheriff" or role == "Murderer") then return true end
    return false
end

local function createHighlight(character, color)
    local highlight = character:FindFirstChild("RoleHighlight")
    if not highlight then
        highlight = Instance.new("Highlight")
        highlight.Name = "RoleHighlight"
        highlight.FillTransparency = 0.5
        highlight.OutlineTransparency = 1
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Adornee = character
        highlight.Parent = character
    end
    highlight.FillColor = color
end

local function removeHighlight(character)
    local highlight = character:FindFirstChild("RoleHighlight")
    if highlight then highlight:Destroy() end
end

local function createTracer(player, color)
    local line = Drawing.new("Line")
    line.Thickness = 2
    line.Color = color or Color3.new(1, 1, 1)
    line.Transparency = 1
    tracers[player] = line
end

local function removeTracer(player)
    if tracers[player] then
        tracers[player]:Remove()
        tracers[player] = nil
    end
end

local function updateESP()
    murderHasKnife = false
    sheriffHasGun = false

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local role = getRole(player)
            if role == "Murderer" then murderHasKnife = true end
            if role == "Sheriff" then sheriffHasGun = true end
        end
    end

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local role = getRole(player)
            local target = isPlayerTargeted(player, currentESPOptions)

            if highlightEnabled then
                if target then
                    local color = role == "Murderer" and PurpleTheme.Error or 
                                 role == "Sheriff" and PurpleTheme.Success or 
                                 PurpleTheme.Primary
                    createHighlight(player.Character, color)
                else
                    removeHighlight(player.Character)
                end
            else
                removeHighlight(player.Character)
            end

            if lineESPEnabled and target then
                local color = role == "Murderer" and PurpleTheme.Error or 
                             role == "Sheriff" and PurpleTheme.Success or 
                             PurpleTheme.Primary
                if not tracers[player] then 
                    createTracer(player, color) 
                else
                    tracers[player].Color = color
                end
            else
                removeTracer(player)
            end
        end
    end
end

-- ==================== AUTO RESET FUNCTION ====================

-- Improved Auto Reset System
if CoinCollected then
    CoinCollected.OnClientEvent:Connect(function(coinType, newAmount, oldAmount, additionalData)
        if coinType == "SnowToken" then
            currentBagAmount = newAmount
            print("[DEBUG] Collected snowflake! Current amount:", currentBagAmount)
            
            -- Check if bag is full (40 for regular, 50 for premium)
            local maxCapacity = 40 -- Default capacity
            
            -- Check for premium gamepass
            local success, hasGamepass = pcall(function()
                return game:GetService("MarketplaceService"):UserOwnsGamePassAsync(LocalPlayer.UserId, 429957)
            end)
            
            if success and hasGamepass then
                maxCapacity = 50
            end
            
            if currentBagAmount >= maxCapacity then
                print("[DEBUG] Bag is full! (" .. maxCapacity .. " snowflakes reached)")
                
                WindUI:Notify({
                    Title = "Bag Full!",
                    Content = "Snowflake bag is full (" .. currentBagAmount .. "/" .. maxCapacity .. ")",
                    Icon = "package",
                    Duration = 3
                })
                
                -- Stop autofarm when bag is full
                autoFarmCandy = false
                bag_full = true
                print("[DEBUG] Stopped autofarm")
                
                -- Auto reset character if enabled
                if autoResetEnabled and not resetting then
                    resetting = true
                    
                    task.wait(0.5)
                    
                    -- Reset character
                    print("[DEBUG] Resetting character...")
                    WindUI:Notify({
                        Title = "üíÄ Auto Reset",
                        Content = "Resetting character instantly!",
                        Icon = "refresh-cw",
                        Duration = 2
                    })
                    
                    if LocalPlayer.Character then
                        LocalPlayer.Character:BreakJoints()
                        LocalPlayer.CharacterAdded:Wait()
                        task.wait(1.5)
                        print("[DEBUG] Character reset completed")
                    end
                    
                    -- Reset farming state
                    resetting = false
                    bag_full = false
                    currentBagAmount = 0
                    autoFarmCandy = true -- Resume farming
                    print("[DEBUG] Farming resumed after reset")
                    
                    WindUI:Notify({
                        Title = "‚úÖ Reset Complete",
                        Content = "Ready to farm again!",
                        Duration = 2
                    })
                end
            end
        end
    end)
end

-- ==================== AUTO FARM FUNCTIONS ====================

-- Function to fly/tween to a position
local function flyTo(pos, speed)
    if not rootPart then return end
    local distance = (pos - rootPart.Position).Magnitude
    local duration = distance / speed
    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear)
    local goal = {CFrame = CFrame.new(pos)}
    local tween = TweenService:Create(rootPart, tweenInfo, goal)
    tween:Play()
    tween.Completed:Wait()
end

-- Function to find coin container
local function findCoinContainer()
    for _, v in workspace:GetChildren() do
        if v:FindFirstChild("CoinContainer") and v:IsA("Model") then
            return v:FindFirstChild("CoinContainer")
        end
    end
    return nil
end

-- Improved snowflake detection function
local function get_nearest_snowflake()
    local hrp = rootPart
    if not hrp then return nil, math.huge end
    
    local closest, dist = nil, math.huge
    
    -- First try CoinContainer method with CoinID attribute
    for _, m in pairs(workspace:GetChildren()) do
        if m:FindFirstChild("CoinContainer") then
            for _, coin in pairs(m.CoinContainer:GetChildren()) do
                if coin:IsA("BasePart") and coin:GetAttribute("CoinID") == "SnowToken" and coin:FindFirstChild("TouchInterest") then
                    local d = (hrp.Position - coin.Position).Magnitude
                    if d < dist and d < 250 and not visitedPositions[coin] then
                        closest, dist = coin, d
                    end
                end
            end
        end
    end
    
    -- Fallback to workspace search by name
    if not closest then
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") and obj.Name == "SnowToken" then
                local d = (hrp.Position - obj.Position).Magnitude
                if d < dist and d < 250 and not visitedPositions[obj] then
                    closest, dist = obj, d
                end
            end
        end
    end
    
    return closest, dist
end

-- Snowflake AutoFarm Loop
task.spawn(function()
    while true do
        if autoFarmCandy and not bag_full then
            character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            rootPart = character:FindFirstChild("HumanoidRootPart")
            
            if rootPart then
                local closest, dist = get_nearest_snowflake()
                
                if closest and closest.Parent and closest:IsDescendantOf(workspace) then
                    if dist > 150 then
                        -- Teleport for distant snowflakes
                        rootPart.CFrame = closest.CFrame
                        print("[DEBUG] Teleported to distant snowflake at distance:", dist)
                    else
                        -- Use tweening for nearby snowflakes
                        flyTo(closest.Position, flySpeed)
                    end
                    
                    if closest and closest.Parent and closest:IsDescendantOf(workspace) then
                        visitedPositions[closest] = true
                        collected += 1
                        print("Collected snowflakes:", collected)
                    end
                end
            end
        end
        
        task.wait(0.1)
    end
end)

-- Disable collisions while flying (Noclip)
RunService.Stepped:Connect(function()
    if autoFarmCandy and character then
        for _, v in ipairs(character:GetDescendants()) do
            if v:IsA("BasePart") then
                v.CanCollide = false
            end
        end
    end
end)

-- Improved Character respawn handling
LocalPlayer.CharacterAdded:Connect(function(char)
    character = char
    rootPart = char:WaitForChild("HumanoidRootPart")
    visitedPositions = {}
    currentBagAmount = 0
    bag_full = false
    resetting = false
    collected = 0
    print("[DEBUG] Character respawned, farming state reset")
end)

-- ==================== WEAPON SPAWNER FUNCTIONS ====================
local function fireBoxController(crateName, itemId)
    print("üî• Attempting to fire BoxController...")
    print("   Crate:", crateName)
    print("   Item:", itemId)
    
    local success, err = pcall(function()
        _B:Fire(crateName, itemId)
    end)
    
    if success then
        print("‚úÖ BoxController fired successfully!")
    else
        warn("‚ùå Failed to fire BoxController:", err)
    end
end

-- ==================== WEAPON SPAWNER TAB ====================
spawnTab:Section({
    Title = "Weapon Spawner Settings"
})

local Input1 = spawnTab:Input({
    Title = "Enter Weapon Name",
    Desc = "Type In Weapon Name (e.g., Gingerscope, Harvester)",
    Value = "",
    InputIcon = "",
    Type = "Input",
    Placeholder = "Weapon Name",
    Callback = function(value)
        itemNameInput = tostring(value)
        print("üìù Weapon Name Input:", itemNameInput)
        
       
    end
})

local Input2 = spawnTab:Input({
    Title = "Quantity",
    Desc = "Quantity To Spawn Of Weapon (1-100)",
    Value = "1",
    InputIcon = "",
    Type = "Input",
    Placeholder = "1",
    Callback = function(value)
        quantityInput = tonumber(value) or 0
        print("üìù Quantity Input:", quantityInput)
       
    end
})

local Button = spawnTab:Button({
    Title = "Spawn Weapon",
    Desc = "Click to spawn the weapon!",
    Locked = false,
    Callback = function()
      
        
        
        -- Validate item name
        if itemNameInput == "" or itemNameInput == nil then
            WindUI:Notify({
                Title = "Error",
                Content = "Please enter a weapon name first!",
                Duration = 3
            })
            warn("‚ùå No weapon name entered")
            return
        end
        
        if not ITEMS[itemNameInput] then
            WindUI:Notify({
                Title = "Error",
                Content = "Invalid weapon: " .. itemNameInput,
                Duration = 3
            })
            warn("‚ùå Invalid weapon name:", itemNameInput)
            return
        end

        -- Validate quantity
        local quantityToAdd = tonumber(quantityInput)
        if not quantityToAdd or quantityToAdd <= 0 then
            WindUI:Notify({
                Title = "Error",
                Content = "Invalid quantity! Enter 1 or more.",
                Duration = 3
            })
            warn("‚ùå Invalid quantity:", quantityInput)
            return
        end
        
        if quantityToAdd > 100 then
            WindUI:Notify({
                Title = "Warning",
                Content = "Quantity too high! Setting to 100.",
                Duration = 3
            })
            quantityToAdd = 100
        end

        -- Get item ID
        local itemId = ITEMS[itemNameInput]
        
        print("‚úÖ Validation passed!")
        print("   Item ID:", itemId)
        print("   Quantity:", quantityToAdd)
        
        WindUI:Notify({
            Title = "Spawning...",
            Content = "Spawning " .. quantityToAdd .. "x " .. itemNameInput,
            Duration = 3
        })

        -- Fire box controller for each quantity
        print("\nüîÑ Starting spawn loop...")
        for i = 1, quantityToAdd do
            print("   Loop iteration:", i .. "/" .. quantityToAdd)
            fireBoxController(crate, itemId)
            task.wait(0.1) -- Small delay between fires
        end
        print("‚úÖ Spawn loop completed!")

        -- Wait 5 seconds then update inventory
        task.delay(5, function()
            print("\nüì¶ Updating inventory...")
            
            -- Initialize inventory if needed
            if not inventory[itemId] then
                inventory[itemId] = 0
            end

            -- Update inventory count
            inventory[itemId] = inventory[itemId] + quantityToAdd
            print("   New inventory count:", inventory[itemId])

            -- Sync with player data
            pcall(function()
                game:GetService("RunService"):BindToRenderStep("InventoryUpdate_" .. itemId, 0, function()
                    PlayerWeapons.Owned[itemId] = inventory[itemId]
                end)
            end)

            -- Show success notification
            WindUI:Notify({
                Title = "Success!",
                Content = "Spawned " .. quantityToAdd .. "x " .. itemNameInput,
                Duration = 4
            })

            print("‚úÖ Inventory updated successfully!")
            print("üíÄ Respawning player...")
            
            -- Respawn player to refresh inventory
            task.wait(1)
            game.Players.LocalPlayer.Character:BreakJoints()
        end)
        
        print("=== SPAWN PROCESS COMPLETE ===\n")
    end
})

-- ==================== WEAPON LIST INFO ====================
spawnTab:Section({
    Title = "Available Weapons"
})

spawnTab:Paragraph({
    Title = "Changelogs",
    Desc = [[
Changelogs: 
‚Äî 15/03/25: Weapon Spawner (V1)
‚Äî 03/04/25: Bug Fixes + New Set (Easter Update)
‚Äî 19/05/25: Fixed Spawning Bug + Added New Saving To Database Mechanism
‚Äî 13/07/25: Weapon Spawner (V2) + Added New Weapons!
‚Äî 15/07/25: Fixed Saving To Inventory Bug & Improved UI.
‚Äî 19/08/25: Added Quantity To Spawn + Fixed Freezing/Kicking Bug (V3)
‚Äî 18/10/25: V4 Beta Spawner + Added New Sets And Fixed Almost EVERY Possible Bug.
    ]]
})

-- ==================== TELEPORT TAB ====================
teleportTab:Section({
    Title = "üöÄ Default Teleport"
})

-- Initialize teleport dropdown
local function initializeTeleportDropdown()
    teleportDropdown = teleportTab:Dropdown({
        Title = "Select Player",
        Values = updateTeleportPlayers(),
        Value = "Select Player",
        Callback = function(selected)
            if selected ~= "Select Player" then
                teleportTarget = Players:FindFirstChild(selected)
            else
                teleportTarget = nil
            end
        end
    })
end

initializeTeleportDropdown()

-- Update dropdown when players join/leave
Players.PlayerAdded:Connect(function(player)
    task.wait(1)
    if teleportDropdown then
        teleportDropdown:Refresh(updateTeleportPlayers())
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if teleportDropdown then
        teleportDropdown:Refresh(updateTeleportPlayers())
    end
end)

teleportTab:Button({
    Title = "Teleport to Player",
    Desc = "Teleport to selected player",
    Callback = teleportToPlayer
})

teleportTab:Button({
    Title = "Update Players List",
    Desc = "Refresh the player list",
    Callback = function()
        if teleportDropdown then
            teleportDropdown:Refresh(updateTeleportPlayers())
            WindUI:Notify({
                Title = "Players Updated",
                Content = "Player list has been refreshed!",
                Duration = 2
            })
        end
    end
})

teleportTab:Section({
    Title = "‚≠ê Special Teleport"
})

teleportTab:Button({
    Title = "Teleport to Lobby",
    Desc = "Return to the lobby spawn",
    Callback = teleportToLobby
})

teleportTab:Button({
    Title = "Teleport to Sheriff",
    Desc = "Instantly teleport to the Sheriff",
    Callback = function()
        UpdateRoles()
        
        if Sheriff then
            local sheriffPlayer = Players:FindFirstChild(Sheriff)
            
            if sheriffPlayer and sheriffPlayer.Character then
                local targetRoot = sheriffPlayer.Character:FindFirstChild("HumanoidRootPart")
                local localRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                
                if targetRoot and localRoot then
                    localRoot.CFrame = targetRoot.CFrame
                    WindUI:Notify({
                        Title = "Teleportation",
                        Content = "Successfully teleported to Sheriff " .. Sheriff,
                        Icon = "check-circle",
                        Duration = 3
                    })
                end
            else
                WindUI:Notify({
                    Title = "Error",
                    Content = "Sheriff not found or unavailable",
                    Icon = "x-circle",
                    Duration = 3
                })
            end
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Sheriff not identified in current match",
                Icon = "x-circle",
                Duration = 3
            })
        end
    end
})

teleportTab:Button({
    Title = "Teleport to Murderer",
    Desc = "Instantly teleport to the Murderer",
    Callback = function()
        UpdateRoles()
        
        if Murder then
            local murderPlayer = Players:FindFirstChild(Murder)
            
            if murderPlayer and murderPlayer.Character then
                local targetRoot = murderPlayer.Character:FindFirstChild("HumanoidRootPart")
                local localRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                
                if targetRoot and localRoot then
                    localRoot.CFrame = targetRoot.CFrame
                    WindUI:Notify({
                        Title = "Teleportation",
                        Content = "Successfully teleported to Murderer " .. Murder,
                        Icon = "check-circle",
                        Duration = 3
                    })
                end
            else
                WindUI:Notify({
                    Title = "Error",
                    Content = "Murderer not found or unavailable",
                    Icon = "x-circle",
                    Duration = 3
                })
            end
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Murderer not identified in current match",
                Icon = "x-circle",
                Duration = 3
            })
        end
    end
})

-- Auto-update roles periodically
task.spawn(function()
    while true do
        UpdateRoles()
        task.wait(3)
    end
end)

-- ==================== AUTO FARM TAB ====================
farmTab:Section({
    Title = "üéÑ Christmas Snow Farm",
    TextSize = 18,
    FontWeight = Enum.FontWeight.SemiBold,
})

farmTab:Toggle({
    Flag = "StartCandyAutofarm",
    Title = "‚õÑÔ∏è Start Snowflake Autofarm",
    Desc = "Automatically collect Snowflakes!",
    Default = false,
    Callback = function(state)
        autoFarmCandy = state
        if state then
            visitedPositions = {} -- Reset visited positions
            collected = 0 -- Reset counter
            
            WindUI:Notify({
                Title = "üéÑ Snowflake Autofarm",
                Content = "Snowflake farming started! ‚õÑÔ∏è"
            })
        else
            WindUI:Notify({
                Title = "üéÑ Snowflake Autofarm",
                Content = "Snowflake farming stopped. ‚õÑÔ∏è"
            })
        end
    end
})

farmTab:Slider({
    Flag = "FlySpeed",
    Title = "üöÄ Farm Speed",
    Desc = "Set the speed for collecting snowflakes",
    Step = 1,
    Value = {
        Min = 12,
        Max = 25,
        Default = 16,
    },
    Callback = function(value)
        flySpeed = value
    end
})

farmTab:Toggle({
    Flag = "AutoResetOnFull",
    Title = "üíÄ Auto Reset When Full",
    Desc = "Automatically reset when snowflake bag is full",
    Default = false,
    Callback = function(state)
        autoResetEnabled = state
        if state then
            WindUI:Notify({
                Title = "üíÄ Auto Reset",
                Content = "Auto reset enabled! Will reset when bag is full.",
                Duration = 3
            })
        else
            WindUI:Notify({
                Title = "üíÄ Auto Reset",
                Content = "Auto reset disabled.",
                Duration = 2
            })
        end
    end
})

local espTab = Window:Tab({
    Title = "ESP",
    Icon = "eye",
    Locked = false,
})

espTab:Section({
    Title = "üëÅÔ∏è ESP & Visual Features",
    TextSize = 16,
    FontWeight = Enum.FontWeight.SemiBold,
})

espTab:Dropdown({
    Flag = "ESPOptions",
    Title = "üéØ ESP Options",
    Desc = "Select which players to highlight",
    Values = {
        {Title = "Esp All", Icon = "users"},
        {Title = "Esp Sheriff", Icon = "shield"},
        {Title = "Esp Murder", Icon = "sword"},
        {Title = "Esp Sheriff / Murder", Icon = "target"}
    },
    Value = "Esp All",
    Callback = function(option)
        currentESPOptions = {option.Title}
        updateESP()
    end
})

espTab:Toggle({
    Flag = "HighlightESP",
    Title = "‚ú® Highlight ESP",
    Desc = "Enable/disable player highlighting",
    Default = true,
    Callback = function(state)
        highlightEnabled = state
        updateESP()
    end
})

espTab:Toggle({
    Flag = "LineESP",
    Title = "üìè Line ESP",
    Desc = "Draw lines to players",
    Default = false,
    Callback = function(state)
        lineESPEnabled = state
        if not state then
            for _, line in pairs(tracers) do line:Remove() end
            tracers = {}
        end
        updateESP()
    end
})

-- ==================== ESP RENDERING ====================
-- Connect ESP updates for line tracers
RunService.RenderStepped:Connect(function()
    if not lineESPEnabled then return end
    local CurrentCamera = workspace.CurrentCamera
    for player, line in pairs(tracers) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = player.Character.HumanoidRootPart
            local screenPos, onScreen = CurrentCamera:WorldToViewportPoint(hrp.Position)
            local rootGuiSize = CurrentCamera.ViewportSize
            if onScreen then
                line.From = Vector2.new(rootGuiSize.X / 2, rootGuiSize.Y)
                line.To = Vector2.new(screenPos.X, screenPos.Y)
                line.Visible = true
            else
                line.Visible = false
            end
        else
            line.Visible = false
        end
    end
end)

-- Monitor player changes for ESP
local function monitorPlayer(player)
    player.CharacterAdded:Connect(function()
        local backpack = player:WaitForChild("Backpack")
        backpack.ChildAdded:Connect(updateESP)
        backpack.ChildRemoved:Connect(updateESP)
        updateESP()
    end)

    if player.Character then
        local backpack = player:FindFirstChild("Backpack")
        if backpack then
            backpack.ChildAdded:Connect(updateESP)
            backpack.ChildRemoved:Connect(updateESP)
        end
    end
end

for _, player in ipairs(Players:GetPlayers()) do monitorPlayer(player) end
Players.PlayerAdded:Connect(monitorPlayer)

-- Player removal handling
Players.PlayerRemoving:Connect(function(player)
    if player == LocalPlayer then
        for _, line in pairs(tracers) do
            if line then line:Remove() end
        end
        tracers = {}
    end
end)

-- Initialize ESP
updateESP()

-- ==================== DEBUG INFO ====================
print("\n‚úÖ Script loaded successfully!")
print("üìã Available weapons:", #ITEMS)
print("üéØ BoxController ready:", _B ~= nil)
print("üéÑ Christmas Snowflake Farm ready!")
print("üöÄ Teleport System ready!")